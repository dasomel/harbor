name: "Build Package Workflow"
env:
  DOCKER_COMPOSE_VERSION: 1.23.0

on:
  push:
    branches:
      - main
      - release-*

jobs:
  BUILD_PACKAGE:
    env:
      BUILD_PACKAGE: true
    runs-on: ubuntu-latest
    permissions:
      contents: read
      packages: write
    steps:
      - name: Set up Go 1.22
        uses: actions/setup-go@v5
        with:
          go-version: 1.23.2
        id: go
      - name: Setup Docker
        uses: docker-practice/actions-setup-docker@master
        with:
          docker_version: 20.10
          docker_channel: stable
      - uses: actions/checkout@v6
      - uses: jitterbit/get-changed-files@v1
        id: changed-files
        with:
          format: space-delimited
          token: ${{ secrets.GITHUB_TOKEN }}
      - uses: actions/checkout@v6
        with:
          path: src/github.com/goharbor/harbor
      - name: Build Base Image
        if: |
          contains(steps.changed-files.outputs.modified, 'Dockerfile.base') ||
          contains(steps.changed-files.outputs.modified, 'VERSION') ||
          contains(steps.changed-files.outputs.modified, '.buildbaselog') ||
          github.ref == 'refs/heads/main'
        run: |
          set -x
          echo "BUILD_BASE=true" >> $GITHUB_ENV
      - name: Build Package
        run: |
          set -x
          env
          df -h
          harbor_target_bucket=""
          target_branch="$(echo ${GITHUB_REF#refs/heads/})"
          harbor_offline_build_bundle=""
          harbor_online_build_bundle=""
          harbor_logs_bucket="harbor-ci-logs"
          harbor_builds_bucket="harbor-builds"
          harbor_releases_bucket="harbor-releases"
          harbor_ci_pipeline_store_bucket="harbor-ci-pipeline-store/latest"
          # the target release version is the version of next release(RC or GA). It needs to be updated on creating new release branch.
          target_release_version=$(cat ./VERSION)
          Harbor_Package_Version=$target_release_version-'build.'$GITHUB_RUN_NUMBER

          if [[ $target_branch == "main" ]]; then
            Harbor_Assets_Version=$Harbor_Package_Version
            harbor_target_bucket=$harbor_builds_bucket
          else
            Harbor_Assets_Version=$target_release_version
            harbor_target_bucket=$harbor_releases_bucket/$target_branch
          fi

          if [[ $target_branch == "release-"* ]]; then
            Harbor_Build_Base_Tag=$target_release_version
          else
            Harbor_Build_Base_Tag=dev
          fi

          build_base_params=" BUILD_BASE=false"
          cd src/github.com/goharbor/harbor
          if [ -z "$BUILD_BASE"  ] || [ "$BUILD_BASE" != "true"  ]; then
            echo "Do not need to build base images!"
          else
            # Pull base from Docker Hub but don't push back (no Docker Hub secrets in fork)
            build_base_params=" BUILD_BASE=true PULL_BASE_FROM_DOCKERHUB=true PUSHBASEIMAGE=false"
          fi
          sudo make package_offline GOBUILDTAGS="include_oss include_gcs" BASEIMAGETAG=${Harbor_Build_Base_Tag} VERSIONTAG=${Harbor_Assets_Version} PKGVERSIONTAG=${Harbor_Package_Version} TRIVYFLAG=true EXPORTERFLAG=true HTTPPROXY= ${build_base_params}
          sudo make package_online GOBUILDTAGS="include_oss include_gcs" BASEIMAGETAG=${Harbor_Build_Base_Tag} VERSIONTAG=${Harbor_Assets_Version} PKGVERSIONTAG=${Harbor_Package_Version} TRIVYFLAG=true EXPORTERFLAG=true HTTPPROXY= ${build_base_params}
          harbor_offline_build_bundle=$(basename harbor-offline-installer-*.tgz)
          harbor_online_build_bundle=$(basename harbor-online-installer-*.tgz)
          echo "Package name is: $harbor_offline_build_bundle"
          echo "Package name is: $harbor_online_build_bundle"

          source tests/ci/build_util.sh
          cp ${harbor_offline_build_bundle}                 harbor-offline-installer-latest.tgz
          cp ${harbor_online_build_bundle}                  harbor-online-installer-latest.tgz

          # Upload to GitHub Artifacts instead of S3
          # uploader ${harbor_offline_build_bundle}           $harbor_target_bucket
          # uploader ${harbor_online_build_bundle}            $harbor_target_bucket
          # uploader harbor-offline-installer-latest.tgz      $harbor_target_bucket
          # uploader harbor-online-installer-latest.tgz       $harbor_target_bucket
          echo "BUILD_BUNDLE=$harbor_offline_build_bundle" >> $GITHUB_ENV




          # Publish to GitHub Container Registry (ghcr.io)
          echo ${{ secrets.GITHUB_TOKEN }} | docker login ghcr.io -u ${{ github.actor }} --password-stdin

          # List built images
          echo "Listing all goharbor images..."
          docker images | grep goharbor || true

          # Define required images to push (matching Helm chart image names)
          # harbor-core, harbor-portal, harbor-jobservice, harbor-registryctl, harbor-db, harbor-exporter use harbor-* naming
          # nginx-photon, registry-photon, redis-photon, trivy-adapter-photon use *-photon naming
          REQUIRED_IMAGES="harbor-core harbor-portal harbor-jobservice harbor-registryctl harbor-db harbor-exporter harbor-log harbor-prepare nginx-photon registry-photon redis-photon trivy-adapter-photon"

          pushed_images=""
          for image_name in $REQUIRED_IMAGES; do
             source_image="goharbor/${image_name}:${Harbor_Assets_Version}"
             ghcr_base="ghcr.io/dasomel/goharbor/${image_name}"
             
             if docker images --format "{{.Repository}}:{{.Tag}}" | grep -q "^${source_image}$"; then
               echo "Pushing ${image_name}..."
               
               # Tag with version
               docker tag $source_image ${ghcr_base}:${Harbor_Assets_Version}
               docker push ${ghcr_base}:${Harbor_Assets_Version}
               
               # Tag with latest
               docker tag $source_image ${ghcr_base}:latest
               docker push ${ghcr_base}:latest
               
               pushed_images="${pushed_images} ${image_name}"
             else
               echo "Image ${source_image} not found, skipping..."
             fi
          done
          echo "PUSHED_IMAGES=${pushed_images}" >> $GITHUB_ENV

      - name: Set packages to public
        if: success()
        run: |
          for pkg in $PUSHED_IMAGES; do
            echo "Setting goharbor/$pkg to public..."
            curl -s -X PATCH \
              -H "Accept: application/vnd.github+json" \
              -H "Authorization: Bearer ${{ secrets.GITHUB_TOKEN }}" \
              -H "X-GitHub-Api-Version: 2022-11-28" \
              "https://api.github.com/user/packages/container/goharbor%2F${pkg}" \
              -d '{"visibility":"public"}' || echo "Failed to set $pkg to public"
          done

      - name: Upload Artifacts
        uses: actions/upload-artifact@v4
        with:
          name: harbor-installers
          path: |
            harbor-offline-installer-*.tgz
            harbor-online-installer-*.tgz
